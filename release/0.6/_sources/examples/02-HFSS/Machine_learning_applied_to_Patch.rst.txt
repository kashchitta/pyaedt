
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\02-HFSS\Machine_learning_applied_to_Patch.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_02-HFSS_Machine_learning_applied_to_Patch.py:


HFSS: machine learning applied to a patch
-----------------------------------------
This example shows how you can use PyAEDT to create a machine learning algorithm in three steps:

#. Generate the database.
#. Create the machine learning algorithm.
#. Implement the model in a PyAEDT method.

While this example supplies the code for all three steps in one Python file, it would be
better to separate the code for each step into its own Python file.

.. GENERATED FROM PYTHON SOURCE LINES 14-17

Perform required imports
~~~~~~~~~~~~~~~~~~~~~~~~
Perform required imports.

.. GENERATED FROM PYTHON SOURCE LINES 17-33

.. code-block:: default


    import json
    import os
    import random
    from math import sqrt

    import joblib
    import numpy as np
    from sklearn.pipeline import make_pipeline
    from sklearn.preprocessing import StandardScaler
    from sklearn.svm import SVR

    from pyaedt import Hfss
    from pyaedt.modeler.stackup_3d import Stackup3D









.. GENERATED FROM PYTHON SOURCE LINES 34-39

Set non-graphical mode
~~~~~~~~~~~~~~~~~~~~~~
Set non-graphical mode. ``"PYAEDT_NON_GRAPHICAL"`` is needed to generate
documentation only.
You can set ``non_graphical`` either to ``True`` or ``False``.

.. GENERATED FROM PYTHON SOURCE LINES 39-42

.. code-block:: default


    non_graphical = os.getenv("PYAEDT_NON_GRAPHICAL", "False").lower() in ("true", "1", "t")








.. GENERATED FROM PYTHON SOURCE LINES 43-59

Generate database
-------------------
This section describes the first step, which is for generating the database.

Generate input
~~~~~~~~~~~~~~
Generate input randomly by creating a function with four inputs: frequency,
substrate permittivity, substrate thickness, and patch width. Frequency is
from 0.1 GHz to 1 GHz. Permittivity is from 1 to 12.

The following code generates a database of 1 frequency x 2 permittivity
x 2 thickness x 2 width. It creates eight cases, which are far too few to
use to train the model but are a sufficient number for testing
the model. Later in this example, you import more than 3,300 different 
cases in a previously generated database of 74 frequencies
x 5 permittivity x 3 thickness x 3 width.

.. GENERATED FROM PYTHON SOURCE LINES 59-68

.. code-block:: default


    tuple_random_frequency_permittivity = []
    frequency_list = [150 * 1e6]
    for in_list in frequency_list:
        for i in range(2):
            random_permittivity = 1 + 11 * int(random.random() * 100) / 100
            temp_tuple = (in_list, random_permittivity)
            tuple_random_frequency_permittivity.append(temp_tuple)








.. GENERATED FROM PYTHON SOURCE LINES 69-79

Thickness is generated from 0.0025 to 0.055 of the wavelength in the void.
Width is generated from 0.5 to 1.5 of the optimal theoretical width:

``c / (2 * frequency * sqrt((permittivity + 1) / 2))``

For each couple of frequency-permittivity, three random thicknesses and three
random widths are generated. Patch length is calculated using the analytic
formula. Using this formula is important because it reduces the sweep
frequency needed for the data recovery. Every case is stored in a list of a
dictionary.

.. GENERATED FROM PYTHON SOURCE LINES 79-128

.. code-block:: default


    dictionary_list = []
    c = 2.99792458e8
    for couple in tuple_random_frequency_permittivity:
        list_thickness = []
        list_width = []
        frequency = couple[0]
        permittivity = couple[1]
        er = permittivity
        wave_length_0 = c / frequency

        min_thickness = 0.0025 * wave_length_0
        inter_thickness = 0.01 * wave_length_0
        max_thickness = 0.055 * wave_length_0
        for i in range(2):
            random_int = random.randint(0, 1)
            if random_int == 0:
                thickness = min_thickness + (inter_thickness - min_thickness) * random.random()
            else:
                thickness = inter_thickness + (max_thickness - inter_thickness) * random.random()
            list_thickness.append(thickness)

        min_width = 0.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        max_width = 1.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        for i in range(2):
            width = min_width + (max_width - min_width) * random.random()
            list_width.append(width)

        for width in list_width:
            for thickness in list_thickness:
                effective_permittivity = (er + 1) / 2 + (er - 1) / (2 * sqrt(1 + 10 * thickness / width))
                er_e = effective_permittivity
                w_h = width / thickness
                added_length = 0.412 * thickness * (er_e + 0.3) * (w_h + 0.264) / ((er_e - 0.258) * (w_h + 0.813))
                wave_length = c / (frequency * sqrt(er_e))
                length = wave_length / 2 - 2 * added_length
                dictionary = {
                    "frequency": frequency,
                    "permittivity": permittivity,
                    "thickness": thickness,
                    "width": width,
                    "length": length,
                    "previous_impedance": 0,
                }
                dictionary_list.append(dictionary)

    print("List of data: " + str(dictionary_list))
    print("Its length is: " + str(len(dictionary_list)))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    List of data: [{'frequency': 150000000.0, 'permittivity': 9.14, 'thickness': 0.018577961775720193, 'width': 0.6303591729003724, 'length': 0.323767430976457, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 9.14, 'thickness': 0.06594282843032499, 'width': 0.6303591729003724, 'length': 0.2999830531173155, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 9.14, 'thickness': 0.018577961775720193, 'width': 0.4538813152017761, 'length': 0.3268029000932943, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 9.14, 'thickness': 0.06594282843032499, 'width': 0.4538813152017761, 'length': 0.30659944105376313, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.28, 'thickness': 0.10506610882369373, 'width': 0.773584943380572, 'length': 0.34207395333972085, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.28, 'thickness': 0.05464812797279983, 'width': 0.773584943380572, 'length': 0.372146042140376, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.28, 'thickness': 0.10506610882369373, 'width': 0.4529834331068656, 'length': 0.356750737560291, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 6.28, 'thickness': 0.05464812797279983, 'width': 0.4529834331068656, 'length': 0.38245600546033687, 'previous_impedance': 0}]
    Its length is: 8




.. GENERATED FROM PYTHON SOURCE LINES 129-135

Generate HFSS design
~~~~~~~~~~~~~~~~~~~~
Generate the HFSS design using the ``Stackup3D`` method.
Open an HFSS design and create the stackup, add the different layers, and add
the patch. In the stackup library, most things, like the layers and patch,
are already parametrized.

.. GENERATED FROM PYTHON SOURCE LINES 135-148

.. code-block:: default


    desktopVersion = "2022.2"

    hfss = Hfss(
        new_desktop_session=True, solution_type="Terminal", non_graphical=non_graphical, specified_version=desktopVersion
    )

    stackup = Stackup3D(hfss)
    ground = stackup.add_ground_layer("ground", material="copper", thickness=0.035, fill_material="air")
    dielectric = stackup.add_dielectric_layer("dielectric", thickness=10, material="Duroid (tm)")
    signal = stackup.add_signal_layer("signal", material="copper", thickness=0.035, fill_material="air")
    patch = signal.add_patch(patch_length=1009.86, patch_width=1185.9, patch_name="Patch", frequency=100e6)








.. GENERATED FROM PYTHON SOURCE LINES 149-152

Resize layers around patch
~~~~~~~~~~~~~~~~~~~~~~~~~~
Resize the layers around the patch so that they change when the patch changes.

.. GENERATED FROM PYTHON SOURCE LINES 152-155

.. code-block:: default


    stackup.resize_around_element(patch)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True



.. GENERATED FROM PYTHON SOURCE LINES 156-159

Create lumped port
~~~~~~~~~~~~~~~~~~
Create a lumped port that is parametrized with the function of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 159-162

.. code-block:: default


    patch.create_lumped_port(reference_layer=ground, opposite_side=False, port_name="one")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.modules.Boundary.BoundaryObject object at 0x0000022BDAE58D00>



.. GENERATED FROM PYTHON SOURCE LINES 163-167

Create line
~~~~~~~~~~~
Create a line that is parametrized with the function of the patch length. This
ensures that the air box is large enough in the normal direction of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 167-178

.. code-block:: default


    points_list = [
        [patch.position_x.name, patch.position_y.name, signal.elevation.name],
        [patch.position_x.name, patch.position_y.name, signal.elevation.name + " + " + patch.length.name],
    ]
    hfss.modeler.primitives.create_polyline(position_list=points_list, name="adjust_airbox")
    pad_percent = [50, 50, 300, 50, 50, 10]
    region = hfss.modeler.primitives.create_region(pad_percent)
    hfss.assign_radiation_boundary_to_objects(region)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.modules.Boundary.BoundaryObject object at 0x0000022BDAEB7940>



.. GENERATED FROM PYTHON SOURCE LINES 179-182

Plot
~~~~
Plot patch

.. GENERATED FROM PYTHON SOURCE LINES 182-185

.. code-block:: default


    hfss.plot(show=False, export_path=os.path.join(hfss.working_directory, "Image.jpg"), plot_air_objects=True)




.. image-sg:: /examples/02-HFSS/images/sphx_glr_Machine_learning_applied_to_Patch_001.png
   :alt: Machine learning applied to Patch
   :srcset: /examples/02-HFSS/images/sphx_glr_Machine_learning_applied_to_Patch_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.generic.plot.ModelPlotter object at 0x0000022BDAEB7640>



.. GENERATED FROM PYTHON SOURCE LINES 186-189

Create setup and sweep
~~~~~~~~~~~~~~~~~~~~~~
Create a setup and a sweep by frequency.

.. GENERATED FROM PYTHON SOURCE LINES 189-217

.. code-block:: default


    print(len(dictionary_list))
    for freq in frequency_list:
        frequency_name = str(int(freq * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        current_setup = hfss.create_setup(setupname=setup_name)
        current_setup.props["Frequency"] = str(freq) + "Hz"
        current_setup.props["MaximumPasses"] = 30
        current_setup.props["MinimumConvergedPasses"] = 2
        current_setup.props["MaxDeltaS"] = 0.05
        current_setup.update()
        current_setup["SaveAnyFields"] = False

        freq_start = freq * 0.75
        freq_stop = freq * 1.25
        sweep_name = "Sweep_of_" + setup_name
        hfss.create_linear_count_sweep(
            setupname=setup_name,
            unit="Hz",
            freqstart=freq_start,
            freqstop=freq_stop,
            num_of_freq_points=25000,
            sweepname="Sweep_of_" + setup_name,
            save_fields=False,
            sweep_type="Interpolating",
        )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    8




.. GENERATED FROM PYTHON SOURCE LINES 218-221

Define function
~~~~~~~~~~~~~~~
Define a function to recover the index of the resonance frequency.

.. GENERATED FROM PYTHON SOURCE LINES 221-245

.. code-block:: default



    def index_of_resonance(imaginary_list, real_list):
        list_of_index = []
        for i in range(1, len(imaginary_list)):
            if imaginary_list[i] * imaginary_list[i - 1] < 0:
                if abs(imaginary_list[i]) < abs(imaginary_list[i - 1]):
                    list_of_index.append(i)
                elif abs(imaginary_list[i]) > abs(imaginary_list[i - 1]):
                    list_of_index.append(i - 1)
        if len(list_of_index) == 0:
            return 0
        elif len(list_of_index) == 1:
            return list_of_index[0]
        else:
            storage = 0
            resonance_index = 0
            for index in list_of_index:
                if storage < real_list[index]:
                    storage = real_list[index]
                    resonance_index = index
            return resonance_index









.. GENERATED FROM PYTHON SOURCE LINES 246-255

Create parametric variation by case
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Use a loop to create a parametric variation by case and associate it with a setup.
The parametric variation is composed of the patch length and width and substrate
permittivity and thickness. For each, measure the real resonance frequency to
obtain the data length, width, permittivity, and thickness that corresponds
to a resonance frequency. Use an error counter to verify that the resonance
frequency is contained in the sweep. To make it easy, calculate the length
of each case using the analytic formula.

.. GENERATED FROM PYTHON SOURCE LINES 255-324

.. code-block:: default


    error_counter = []
    for i in range(len(dictionary_list)):
        dictio = dictionary_list[i]
        frequency_name = str(int(dictio["frequency"] * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        sweep_name = "Sweep_of_" + setup_name
        length_variation = dictio["length"] * 1e3
        width_variation = dictio["width"] * 1e3
        thickness_variation = dictio["thickness"] * 1e3
        permittivity_variation = dictio["permittivity"]
        param_name = "para_" + setup_name + "_" + str(i)
        this_param = hfss.parametrics.add(
            patch.length.name,
            length_variation,
            length_variation,
            step=1,
            variation_type="LinearCount",
            solution=setup_name,
            parametricname=param_name,
        )
        this_param.add_variation(
            patch.width.name, width_variation, width_variation, step=1, unit=None, variation_type="LinearCount"
        )
        this_param.add_variation(
            dielectric.thickness.name,
            thickness_variation,
            thickness_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        this_param.add_variation(
            "$cloned_Duroid__tm__permittivity",
            permittivity_variation,
            permittivity_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        hfss.analyze_setup(param_name, num_cores=4, num_tasks=None)
        data = hfss.post.get_solution_data(
            "Zt(one_T1, one_T1)",
            setup_sweep_name=setup_name + " : " + sweep_name,
            domain="Sweep",
            variations={
                patch.length.name: [str(length_variation) + "mm"],
                patch.width.name: [str(width_variation) + "mm"],
                dielectric.thickness.name: [str(thickness_variation) + "mm"],
                "$cloned_Duroid__tm__permittivity": [str(permittivity_variation)],
            },
            polyline_points=25000,
        )
        imaginary_part = data.data_imag()
        real_part = data.data_real()
        corresponding_index = index_of_resonance(imaginary_part, real_part)
        if corresponding_index == 0:
            hfss.logger.error("The resonance is out of the range")
            error_counter.append(i)
        minimum_imaginary = imaginary_part[corresponding_index]
        previous_impedance = real_part[corresponding_index]
        print("minimum_imaginary: " + str(minimum_imaginary))
        print("previous_impedance: " + str(previous_impedance))
        frequency_list = data.primary_sweep_values
        resonance_frequency = frequency_list[corresponding_index]
        print(resonance_frequency)
        dictio["frequency"] = resonance_frequency
        dictio["previous_impedance"] = previous_impedance





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    minimum_imaginary: 0.10639316264224495
    previous_impedance: 243.6165098207626
    0.141346153846154
    minimum_imaginary: -0.04617557344674203
    previous_impedance: 212.17323650661967
    0.132477799111964
    minimum_imaginary: -0.2346465996459997
    previous_impedance: 313.93652078185403
    0.139837093483739
    minimum_imaginary: -0.03025986748780272
    previous_impedance: 261.2742606683127
    0.136266950678027
    minimum_imaginary: -0.01388116474492089
    previous_impedance: 181.78164617179857
    0.13575993039721598
    minimum_imaginary: -0.045056653351669904
    previous_impedance: 190.7687451133929
    0.138190027601104
    minimum_imaginary: -0.05156153325106587
    previous_impedance: 255.976368626727
    0.134733889355574
    minimum_imaginary: 0.08583660432012784
    previous_impedance: 258.0243456369514
    0.138661046441858




.. GENERATED FROM PYTHON SOURCE LINES 325-328

Print error
~~~~~~~~~~~
Print the number of range error.

.. GENERATED FROM PYTHON SOURCE LINES 328-331

.. code-block:: default


    print("number of range error: " + str(error_counter))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of range error: []




.. GENERATED FROM PYTHON SOURCE LINES 332-336

End data recovery step
~~~~~~~~~~~~~~~~~~~~~~
End the data recovery step by dumping the dictionary list into a JSON file.
Saving the data allows you to use it in another Python script.

.. GENERATED FROM PYTHON SOURCE LINES 336-341

.. code-block:: default


    json_file_path = os.path.join(hfss.working_directory, "ml_data_for_test.json")
    with open(json_file_path, "w") as readfile:
        json.dump(dictionary_list, readfile)








.. GENERATED FROM PYTHON SOURCE LINES 342-352

Create machine learning algorithm
----------------------------------
This section describes the second step, which is for creating the machine
learning algorithm.

Import training cases
~~~~~~~~~~~~~~~~~~~~~
Import the 3,300 cases in the supplied JSON file to train the model. As mentioned
earlier, you cannot use the small database that you generated earlier for training
the model. Its 8 cases are used later to test the model.

.. GENERATED FROM PYTHON SOURCE LINES 352-364

.. code-block:: default


    path_folder = hfss.pyaedt_dir
    training_file = os.path.join(path_folder, "misc", "ml_data_file_train_100MHz_1GHz.json")
    with open(training_file) as readfile:
        my_dictio_list_train = json.load(readfile)

    with open(json_file_path, "r") as readfile:
        my_dictio_list_test = json.load(readfile)

    print(len(my_dictio_list_train))
    print(len(my_dictio_list_test))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    3330
    8




.. GENERATED FROM PYTHON SOURCE LINES 365-373

Create lists
~~~~~~~~~~~~
Create four lists:

- One for the input of the training
- One for the output of training
- Oone for the input of the test
- One for the output of the test

.. GENERATED FROM PYTHON SOURCE LINES 373-380

.. code-block:: default



    input_for_training_list = []
    output_for_training_list = []
    input_for_test_list = []
    output_for_test_list = []








.. GENERATED FROM PYTHON SOURCE LINES 381-386

Fill list for input of training
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Fill the list for the input of the training with frequency, width, permittivity,
and thickness so that the output is the length. The objective of this
algorithm is to predict the length according to the rest.

.. GENERATED FROM PYTHON SOURCE LINES 386-412

.. code-block:: default


    for i in range(len(my_dictio_list_train)):
        freq_width_perm_thick = [
            my_dictio_list_train[i]["frequency"] * 1e9,
            my_dictio_list_train[i]["width"] * 1000,
            my_dictio_list_train[i]["permittivity"],
            my_dictio_list_train[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_train[i]["length"] * 1000
        input_for_training_list.append(freq_width_perm_thick)
        output_for_training_list.append(length)

    for i in range(len(my_dictio_list_test)):
        freq_width_perm_thick = [
            my_dictio_list_test[i]["frequency"] * 1e9,
            my_dictio_list_test[i]["width"] * 1000,
            my_dictio_list_test[i]["permittivity"],
            my_dictio_list_test[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_test[i]["length"] * 1000
        input_for_test_list.append(freq_width_perm_thick)
        output_for_test_list.append(length)

    print("number of test cases: " + str(len(output_for_test_list)))
    print("number of training cases: " + str(len(output_for_training_list)))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of test cases: 8
    number of training cases: 3330




.. GENERATED FROM PYTHON SOURCE LINES 413-416

Convert lists in array
~~~~~~~~~~~~~~~~~~~~~~
Convert the lists in an array.

.. GENERATED FROM PYTHON SOURCE LINES 416-425

.. code-block:: default


    input_for_training_array = np.array(input_for_training_list, dtype=np.float32)
    output_for_training_array = np.array(output_for_training_list, dtype=np.float32)
    input_for_test_array = np.array(input_for_test_list, dtype=np.float32)
    output_for_test_array = np.array(output_for_test_list, dtype=np.float32)

    print("input array for training: " + str(input_for_training_array))
    print("output array for training: " + str(output_for_training_array))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input array for training: [[8.5343952e+07 1.8699978e+03 1.0000000e+00 1.3607236e+02]
     [8.7562560e+07 1.8699978e+03 1.0000000e+00 3.1649155e+01]
     [8.5523544e+07 1.8699978e+03 1.0000000e+00 1.6327014e+02]
     ...
     [9.5384678e+08 3.3421940e+01 1.1450000e+01 1.0995456e+01]
     [1.1057147e+09 3.3421940e+01 1.1450000e+01 2.1035936e+00]
     [9.7680755e+08 3.3421940e+01 1.1450000e+01 1.3259815e+01]]
    output array for training: [1463.626    1607.3876   1427.5016   ...   36.353287   39.326664
       35.355724]




.. GENERATED FROM PYTHON SOURCE LINES 426-446

Create model
~~~~~~~~~~~~
Create the model. Depending on the app, you can use different models.
The easiest way to find the correct model for an app is to search
for this app or one that is close to it.

To predict characteristics of a patch antenna (resonance frequency, bandwidth,
and input impedance), you can use SVR (Support Vector Regression) or ANN
(Analyze Neuronal Network). The following code uses SVR because it is easier
to implement. ANN is a more general method that also works with other
high frequency components. While it is more likely to work for other app,
implementing ANN is much more complex.

For SVR, there are three different kernels. For the patch antenna, RBF (Radial Basic
Function) is preferred. There are three other arguments that have a big impact
on the accuracy of the model: C, gamma, and epsilon. Sometimes they are given
with the necessary model for the app. Otherwise, you can try different
values and see which one is the best by measuring the accuracy of the model.
To make this example shorter, ``C=1e4``. However, the optimal value
in this app is ``C=5e4``.

.. GENERATED FROM PYTHON SOURCE LINES 446-450

.. code-block:: default


    svr_rbf = SVR(kernel="rbf", C=1e4, gamma="auto", epsilon=0.05)
    regression = make_pipeline(StandardScaler(), svr_rbf)








.. GENERATED FROM PYTHON SOURCE LINES 451-454

Train model
~~~~~~~~~~~
Train the model.

.. GENERATED FROM PYTHON SOURCE LINES 454-457

.. code-block:: default


    regression.fit(input_for_training_array, output_for_training_array)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" ><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" ><label for="sk-estimator-id-2" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler()</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" ><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">SVR</label><div class="sk-toggleable__content"><pre>SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;)</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 458-462

Dump model into JOBLIB file
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Dump the model into a JOBLIB file using the same method as you used earlier
for the JSON file.

.. GENERATED FROM PYTHON SOURCE LINES 462-466

.. code-block:: default


    model_file = os.path.join(hfss.working_directory, "svr_model.joblib")
    joblib.dump(regression, model_file)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['D:/Project/Project1082.pyaedt\\HFSS_PQD\\svr_model.joblib']



.. GENERATED FROM PYTHON SOURCE LINES 467-477

Implement model in PyAEDT method
-------------------------------------
This section describes the third step, which is for implementing the model
in the PyAEDT method.

Load model
~~~~~~~~~~
Load the model in another Python file to predict different cases.
Here the correct model with ``C=5e4`` is loaded rather than the one you made
earlier with ``C=1e4``.

.. GENERATED FROM PYTHON SOURCE LINES 477-481

.. code-block:: default


    model_path = os.path.join(path_folder, "misc", "patch_svr_model_100MHz_1GHz.joblib")
    regression = joblib.load(model_path)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator StandardScaler from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator SVR from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator Pipeline from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(




.. GENERATED FROM PYTHON SOURCE LINES 482-486

Predict length of patch
~~~~~~~~~~~~~~~~~~~~~~~
Predict the length of the patch as a function of its resonant frequency and width
and substrate thickness and permittivity.

.. GENERATED FROM PYTHON SOURCE LINES 486-489

.. code-block:: default


    prediction_of_length = regression.predict(input_for_test_list)








.. GENERATED FROM PYTHON SOURCE LINES 490-493

Measure model efficiency
~~~~~~~~~~~~~~~~~~~~~~~~
Measure the model efficiency.

.. GENERATED FROM PYTHON SOURCE LINES 493-545

.. code-block:: default


    average_relative_gap = 0
    counter_under_zero_five = 0
    counter_under_one = 0
    counter_under_two = 0
    counter_under_five = 0
    counter_under_ten = 0
    counter_upper_ten = 0
    rel_counter_under_one = 0
    rel_counter_under_two = 0
    rel_counter_under_five = 0
    rel_counter_under_ten = 0
    rel_counter_under_twenty = 0
    rel_counter_upper_twenty = 0
    for index in range(len(prediction_of_length)):
        print(
            "value: "
            + str(input_for_test_list[index])
            + ", prediction: "
            + str(prediction_of_length[index] * 1000)
            + ", reality: "
            + str(output_for_test_list[index] * 1000)
        )
        gap = abs(prediction_of_length[index] - output_for_test_list[index])
        relative_gap = gap / output_for_test_list[index]
        average_relative_gap = average_relative_gap + relative_gap
        if gap < 0.5:
            counter_under_zero_five += 1
        elif 0.5 <= gap < 1:
            counter_under_one += 1
        elif 1 <= gap < 2:
            counter_under_two += 1
        elif 2 <= gap < 5:
            counter_under_five += 1
        elif 5 <= gap < 10:
            counter_under_ten += 1
        else:
            counter_upper_ten += 1
        if relative_gap < 0.01:
            rel_counter_under_one += 1
        elif relative_gap < 0.02:
            rel_counter_under_two += 1
        elif relative_gap < 0.05:
            rel_counter_under_five += 1
        elif relative_gap < 0.1:
            rel_counter_under_ten += 1
        elif relative_gap < 0.2:
            rel_counter_under_twenty += 1
        else:
            rel_counter_upper_twenty += 1
    average_relative_gap = average_relative_gap / len(prediction_of_length)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    value: [141346153.846154, 630.3591729003723, 9.14, 18.577961775720194], prediction: 334972.6565272059, reality: 323767.43097645696
    value: [132477799.111964, 630.3591729003723, 9.14, 65.942828430325], prediction: 313026.522052882, reality: 299983.05311731546
    value: [139837093.483739, 453.8813152017761, 9.14, 18.577961775720194], prediction: 332244.6262628048, reality: 326802.90009329433
    value: [136266950.678027, 453.8813152017761, 9.14, 65.942828430325], prediction: 305188.4362589687, reality: 306599.44105376315
    value: [135759930.397216, 773.5849433805721, 6.28, 105.06610882369372], prediction: 301312.5538704634, reality: 342073.95333972084
    value: [138190027.601104, 773.5849433805721, 6.28, 54.648127972799834], prediction: 384047.429698462, reality: 372146.042140376
    value: [134733889.355574, 452.9834331068656, 6.28, 105.06610882369372], prediction: 363529.8962586559, reality: 356750.737560291
    value: [138661046.441858, 452.9834331068656, 6.28, 54.648127972799834], prediction: 388991.4352202808, reality: 382456.00546033686




.. GENERATED FROM PYTHON SOURCE LINES 546-548

The first displays are the gap ``(prediction - real)``. The second displays are
the relative gap ``((prediction - real)/real)``.

.. GENERATED FROM PYTHON SOURCE LINES 548-588

.. code-block:: default


    print("sample size: " + str(len(prediction_of_length)))
    print("<0.5 : " + str(counter_under_zero_five))
    print("<1 : " + str(counter_under_one))
    print("<2 : " + str(counter_under_two))
    print("<5 : " + str(counter_under_five))
    print("<10 : " + str(counter_under_ten))
    print(">10 : " + str(counter_upper_ten) + "\n")
    print(
        "sum : "
        + str(
            counter_under_zero_five
            + counter_under_one
            + counter_under_two
            + counter_under_five
            + counter_under_ten
            + counter_upper_ten
        )
    )

    print("-------------------------------------------\n")
    print("<0.01 : " + str(rel_counter_under_one))
    print("<0.02 : " + str(rel_counter_under_two))
    print("<0.05 : " + str(rel_counter_under_five))
    print("<0.1 : " + str(rel_counter_under_ten))
    print("<0.2 : " + str(rel_counter_under_twenty))
    print(">0.2 : " + str(rel_counter_upper_twenty))
    print(
        "sum : "
        + str(
            rel_counter_under_one
            + rel_counter_under_two
            + rel_counter_under_five
            + rel_counter_under_ten
            + rel_counter_under_twenty
            + rel_counter_upper_twenty
        )
    )
    print("average is : " + str(average_relative_gap))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    sample size: 8
    <0.5 : 0
    <1 : 0
    <2 : 1
    <5 : 0
    <10 : 3
    >10 : 4

    sum : 8
    -------------------------------------------

    <0.01 : 1
    <0.02 : 3
    <0.05 : 3
    <0.1 : 0
    <0.2 : 1
    >0.2 : 0
    sum : 8
    average is : 0.03582170857670036




.. GENERATED FROM PYTHON SOURCE LINES 589-592

Release AEDT
------------
Release AEDT.

.. GENERATED FROM PYTHON SOURCE LINES 592-594

.. code-block:: default


    hfss.release_desktop()




.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 9 minutes  49.749 seconds)


.. _sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: Machine_learning_applied_to_Patch.py <Machine_learning_applied_to_Patch.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: Machine_learning_applied_to_Patch.ipynb <Machine_learning_applied_to_Patch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
